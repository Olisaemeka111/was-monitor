name: AWS Monitor CI/CD

# Required secrets for this workflow:
# AWS_ACCESS_KEY_ID: AWS access key for deploying infrastructure and pushing to ECR
# AWS_SECRET_ACCESS_KEY: AWS secret key for deploying infrastructure and pushing to ECR
# GITHUB_TOKEN: Automatically provided by GitHub, used for repository access

on:
  push:
    branches: [ main ]

env:
  AWS_REGION: us-east-1
  TERRAFORM_WORKING_DIR: terraform

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.image-tag.outputs.tag }}

    steps:
    - uses: actions/checkout@v3

    - name: Set up Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'npm'

    - name: Install dependencies and update lock file
      run: |
        rm -f package-lock.json
        npm install

    - name: Run linting
      run: npm run lint || true

    - name: Build application
      run: npm run build

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y jq bc

    - name: Run tests
      run: npm test || true

    - name: Generate image tag
      id: image-tag
      run: |
        echo "tag=$(date +%Y%m%d%H%M%S)-${GITHUB_SHA::8}" >> $GITHUB_OUTPUT

  setup-terraform-state:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    permissions:
      id-token: write
      contents: read
    outputs:
      state_bucket: ${{ steps.state-setup.outputs.state_bucket }}
      state_lock_table: ${{ steps.state-setup.outputs.state_lock_table }}
    
    steps:
    - uses: actions/checkout@v3

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        mask-aws-account-id: true

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v2

    - name: Initialize Terraform for state setup
      working-directory: ${{ env.TERRAFORM_WORKING_DIR }}
      run: terraform init

    - name: Get existing state resources
      id: state-setup
      working-directory: ${{ env.TERRAFORM_WORKING_DIR }}
      run: |
        echo "state_bucket=aws-monitor-tf-state-156041437006" >> $GITHUB_OUTPUT
        echo "state_lock_table=aws-monitor-tf-lock-156041437006" >> $GITHUB_OUTPUT

  build-and-push-image:
    needs: [setup-terraform-state, build-and-test]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    permissions:
      id-token: write
      contents: read
    outputs:
      image_url: ${{ steps.build-push.outputs.image_url }}
    
    steps:
    - uses: actions/checkout@v3

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v1

    - name: Build and push image to ECR
      id: build-push
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ needs.build-and-test.outputs.image_tag }}
      run: |
        docker build -t $ECR_REGISTRY/aws-monitor:$IMAGE_TAG .
        docker push $ECR_REGISTRY/aws-monitor:$IMAGE_TAG
        echo "image_url=$ECR_REGISTRY/aws-monitor:$IMAGE_TAG" >> $GITHUB_OUTPUT

  deploy-infrastructure:
    needs: [setup-terraform-state, build-and-push-image]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    permissions:
      id-token: write
      contents: read
    outputs:
      ecr_repository: ${{ steps.terraform-outputs.outputs.ecr_repository }}
      task_definition: ${{ steps.terraform-outputs.outputs.task_definition }}
      ecs_service: ${{ steps.terraform-outputs.outputs.ecs_service }}
      ecs_cluster: ${{ steps.terraform-outputs.outputs.ecs_cluster }}
      load_balancer_url: ${{ steps.terraform-outputs.outputs.load_balancer_url }}
    
    steps:
    - uses: actions/checkout@v3

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        mask-aws-account-id: true

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v2

    - name: Configure Terraform backend
      working-directory: ${{ env.TERRAFORM_WORKING_DIR }}
      run: |
        cat > backend.tf << 'EOF'
        terraform {
          backend "s3" {
            bucket         = "aws-monitor-tf-state-156041437006"
            key            = "terraform.tfstate"
            region         = "us-east-1"
            dynamodb_table = "aws-monitor-tf-lock-156041437006"
            encrypt        = true
          }
        }
        EOF

    - name: Terraform Init with S3 backend
      working-directory: ${{ env.TERRAFORM_WORKING_DIR }}
      run: terraform init -reconfigure

    - name: Terraform Apply
      working-directory: ${{ env.TERRAFORM_WORKING_DIR }}
      run: terraform apply -auto-approve

    - name: Get Terraform Outputs
      id: terraform-outputs
      working-directory: ${{ env.TERRAFORM_WORKING_DIR }}
      run: |
        # Function to safely get Terraform output
        get_tf_output() {
          local output_name=$1
          local output_file
          output_file=$(mktemp)
          
          # Get raw output to temp file to avoid debug messages
          if ! terraform output -raw "$output_name" > "$output_file" 2>/dev/null; then
            echo "Error: Failed to get $output_name output" >&2
            rm -f "$output_file"
            return 1
          fi
          
          # Read the output value
          value=$(<"$output_file")
          rm -f "$output_file"
          
          if [ -z "$value" ]; then
            echo "Error: Empty value for $output_name" >&2
            return 1
          fi
          
          echo "$value"
        }
        
        # Get each output individually and validate
        echo "Fetching Terraform outputs..."
        
        ECR_REPO=$(get_tf_output "ecr_repository_url")
        echo "ECR Repository URL: $ECR_REPO"
        
        TASK_DEF=$(get_tf_output "task_definition_family")
        echo "Task Definition Family: $TASK_DEF"
        
        ECS_SERVICE=$(get_tf_output "ecs_service_name")
        echo "ECS Service Name: $ECS_SERVICE"
        
        ECS_CLUSTER=$(get_tf_output "ecs_cluster_name")
        echo "ECS Cluster Name: $ECS_CLUSTER"
        
        LB_URL=$(get_tf_output "load_balancer_url")
        echo "Load Balancer URL: $LB_URL"
        
        # Validate all outputs are present
        if [ -z "$ECR_REPO" ] || [ -z "$TASK_DEF" ] || [ -z "$ECS_SERVICE" ] || 
           [ -z "$ECS_CLUSTER" ] || [ -z "$LB_URL" ]; then
          echo "Error: One or more required outputs are missing"
          exit 1
        fi
        
        # Set GitHub outputs
        {
          echo "ecr_repository=$ECR_REPO"
          echo "task_definition=$TASK_DEF"
          echo "ecs_service=$ECS_SERVICE"
          echo "ecs_cluster=$ECS_CLUSTER"
          echo "load_balancer_url=$LB_URL"
        } >> "$GITHUB_OUTPUT"
        
        echo "Successfully set all outputs"





  deploy-to-ecs:
    needs: [deploy-infrastructure]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    permissions:
      id-token: write
      contents: read
      actions: read
      security-events: write

    steps:
    - uses: actions/checkout@v3

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        mask-aws-account-id: true

    - name: Download task definition
      run: |
        echo "Listing all task definitions for aws-monitor family..."
        aws ecs list-task-definitions --family-prefix aws-monitor --sort DESC --max-items 5
        
        echo "\nGetting latest active task definition..."
        TASK_DEF_ARN=$(aws ecs list-task-definitions --family-prefix aws-monitor --sort DESC --max-items 1 --query 'taskDefinitionArns[0]' --output text)
        echo "Latest task definition ARN: $TASK_DEF_ARN"
        
        echo "\nExtracting task definition family and revision..."
        TASK_DEF_FAMILY=$(echo "$TASK_DEF_ARN" | cut -d'/' -f2 | cut -d':' -f1)
        TASK_DEF_REVISION=$(echo "$TASK_DEF_ARN" | cut -d':' -f3)
        echo "Family: $TASK_DEF_FAMILY"
        echo "Revision: $TASK_DEF_REVISION"
        
        echo "\nDownloading task definition..."
        aws ecs describe-task-definition \
          --task-definition "$TASK_DEF_FAMILY:$TASK_DEF_REVISION" \
          --query taskDefinition > task-definition.json
        
        echo "\nTask definition content:"
        cat task-definition.json

    - name: Fill in the new image ID in the Amazon ECS task definition
      id: task-def
      uses: aws-actions/amazon-ecs-render-task-definition@v1
      with:
        task-definition: task-definition.json
        container-name: aws-monitor
        image: ${{ needs.deploy-infrastructure.outputs.ecr_repository }}:${{ github.sha }}

    - name: Deploy Amazon ECS task definition
      uses: aws-actions/amazon-ecs-deploy-task-definition@v1
      with:
        task-definition: ${{ steps.task-def.outputs.task-definition }}
        service: ${{ needs.deploy-infrastructure.outputs.ecs_service }}
        cluster: ${{ needs.deploy-infrastructure.outputs.ecs_cluster }}
        wait-for-service-stability: true

    - name: Display Application URL
      id: app-url
      run: |
        # Get and validate load balancer URL
        LB_URL="${{ needs.deploy-infrastructure.outputs.load_balancer_url }}"
        echo "Debug: Raw load balancer URL from Terraform = '$LB_URL'"
        
        if [ -z "$LB_URL" ]; then
          echo "Error: Load balancer URL is empty. Checking Terraform outputs..."
          cd ${{ env.TERRAFORM_WORKING_DIR }}
          terraform output
          exit 1
        fi
        
        # Construct and store application URL
        APP_URL="http://$LB_URL"
        echo "url=$APP_URL" >> $GITHUB_OUTPUT
        echo "✨ Application is now available at: $APP_URL"

    - name: Wait for application to be healthy
      run: |
        APP_URL="${{ steps.app-url.outputs.url }}"
        echo "Waiting for application to be healthy at: $APP_URL"
        
        MAX_ATTEMPTS=60
        ATTEMPT=1
        while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
          echo "Debug: Attempt $ATTEMPT - Curling '$APP_URL'"
          echo "Debug: Full curl output:"
          
          # Use temporary files for better output handling
          HEADERS_FILE=$(mktemp)
          BODY_FILE=$(mktemp)
          
          # Perform curl request with detailed output
          HTTP_CODE=$(curl -s -w '%{http_code}' \
                         -D "$HEADERS_FILE" \
                         -o "$BODY_FILE" \
                         -H 'User-Agent: GitHub-Actions-Health-Check' \
                         "$APP_URL" 2>&1)
          
          echo "Debug: Response headers:"
          cat "$HEADERS_FILE"
          echo "Debug: Response body:"
          cat "$BODY_FILE"
          echo "Debug: HTTP status code = $HTTP_CODE"
          
          # Clean up temp files
          rm -f "$HEADERS_FILE" "$BODY_FILE"
          
          if [[ "$HTTP_CODE" =~ ^[23] ]]; then
            echo "✅ Application is healthy! (HTTP $HTTP_CODE)"
            exit 0
          fi
          
          echo "Attempt $ATTEMPT: Application returned HTTP $HTTP_CODE, waiting 10 seconds..."
          sleep 10
          ATTEMPT=$((ATTEMPT + 1))
        done
        
        echo "❌ Application health check failed after 10 minutes"
        exit 1
        echo "⏳ Note: It may take a few minutes for DNS to propagate and the application to be fully available"
        echo "url=$APP_URL" >> $GITHUB_OUTPUT

    - name: Wait for Application Health
      run: |
        echo "Debug: Load balancer URL from Terraform = ${{ needs.deploy-infrastructure.outputs.load_balancer_url }}"
        APP_URL="http://${{ needs.deploy-infrastructure.outputs.load_balancer_url }}"
        echo "Debug: Full application URL = $APP_URL"
        
        echo "Waiting for application to be healthy..."
        for i in {1..60}; do
          echo "Debug: Attempt $i - Curling $APP_URL"
          HTTP_STATUS=$(curl -v "$APP_URL" 2>&1 || true)
          echo "Debug: Full curl output:"
          echo "$HTTP_STATUS"
          
          STATUS_CODE=$(echo "$HTTP_STATUS" | grep -o 'HTTP/[0-9.]* [0-9]\{3\}' | tail -1 | awk '{print $2}')
          echo "Debug: Extracted status code = $STATUS_CODE"
          
          if [[ "$STATUS_CODE" =~ ^(200|301|302|303|307|308)$ ]]; then
            echo "✅ Application is healthy and responding with HTTP $STATUS_CODE"
            exit 0
          fi
          echo "Attempt $i: Application returned HTTP $STATUS_CODE, waiting 10 seconds..."
          sleep 10
        done
        echo "❌ Application health check failed after 10 minutes"
        exit 1

    - name: Verify API Endpoints
      run: |
        echo "Testing key API endpoints..."
        APP_URL="${{ steps.app-url.outputs.url }}"
        
        # Test root endpoint
        ROOT_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$APP_URL")
        echo "Root endpoint (/) status: $ROOT_STATUS"
        
        # Test accounts endpoint
        ACCOUNTS_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$APP_URL/api/accounts")
        echo "Accounts endpoint (/api/accounts) status: $ACCOUNTS_STATUS"
        
        # Test metrics endpoint
        METRICS_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$APP_URL/api/metrics")
        echo "Metrics endpoint (/api/metrics) status: $METRICS_STATUS"
        
        # Verify all endpoints are responding
        if [ "$ROOT_STATUS" = "200" ] && [ "$ACCOUNTS_STATUS" = "200" ] && [ "$METRICS_STATUS" = "200" ]; then
          echo "✅ All endpoints are responding correctly"
        else
          echo "❌ Some endpoints are not responding correctly"
          exit 1
        fi

    - name: Check CloudWatch Metrics
      run: |
        echo "Checking CloudWatch metrics for the service..."
        
        # Get timestamps for 5 minutes ago and now
        START_TIME=$(date -u -d '5 minutes ago' +%Y-%m-%dT%H:%M:%S)
        END_TIME=$(date -u +%Y-%m-%dT%H:%M:%S)
        
        # Check ECS service metrics
        aws cloudwatch get-metric-statistics \
          --namespace AWS/ECS \
          --metric-name CPUUtilization \
          --dimensions Name=ClusterName,Value=${{ needs.deploy-infrastructure.outputs.ecs_cluster }} Name=ServiceName,Value=${{ needs.deploy-infrastructure.outputs.ecs_service }} \
          --start-time "$START_TIME" \
          --end-time "$END_TIME" \
          --period 300 \
          --statistics Average
        
        # Check ALB metrics
        aws cloudwatch get-metric-statistics \
          --namespace AWS/ApplicationELB \
          --metric-name TargetResponseTime \
          --dimensions Name=LoadBalancer,Value=${{ needs.deploy-infrastructure.outputs.load_balancer_url }} \
          --start-time "$START_TIME" \
          --end-time "$END_TIME" \
          --period 300 \
          --statistics Average
